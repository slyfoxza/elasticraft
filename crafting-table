#!/usr/bin/env python
# Copyright 2019 Philip Cronje
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
import boto3
import botocore
import click
import ipaddress
import os
import sys


class CraftingTableError(Exception):
    def __init__(self, message):
        super().__init__(message)


@click.group()
@click.pass_context
@click.option("--profile")
def cli(context, profile):
    botocore_session = botocore.session.Session(profile=profile)
    creds_provider = botocore_session.get_component("credential_provider").get_provider("assume-role")
    creds_provider.cache = botocore.credentials.JSONFileCache(os.path.expanduser("~/.aws/cli/cache"))
    boto_session = boto3.Session(botocore_session=botocore_session)
    context.obj = boto_session.resource("ec2")


def find_vpc(ec2):
    """
    Finds exactly one VPC tagged with "elasticraft:vpc" that was created by the CloudFormation template. If
    multiple VPCs are found, or none at all, a CraftingTableError is raised.
    """
    vpcs = list(ec2.vpcs.filter(Filters=[
        {"Name": "tag:elasticraft", "Values": ["vpc"]},
        {"Name": "tag:aws:cloudformation:logical-id", "Values": ["Vpc"]}]))
    if len(vpcs) == 1:
        return vpcs[0]
    elif len(vpcs) == 0:
        raise CraftingTableError("No VPC found")
    else:
        ids = ", ".join(map(lambda vpc: vpc.id, vpcs))
        raise CraftingTableError(f"Multiple VPCs found: {ids}")


def create_subnets(ec2, vpc, subnets):
    """Ensure subnets exist for each availability zone."""
    # Generate candidate subnet CIDRs by shifting the VPC's prefix by 4 bits, yielding 16 possible subnet
    # CIDRs.
    vpc_cidr = ipaddress.ip_network(vpc.cidr_block)
    subnet_cidrs = list(vpc_cidr.subnets(prefixlen_diff=4))

    # The set difference between the availability zones that already have subnets and the availability zones
    # available in the region yields the set of availability zones where subnets must be created.
    subnet_azs = frozenset(map(lambda subnet: subnet.availability_zone, subnets))
    available_azs = frozenset(map(
        lambda az: az["ZoneName"], ec2.meta.client.describe_availability_zones()["AvailabilityZones"]))

    for az in (available_azs - subnet_azs):
        # If subnets already exist, their CIDRs may conflict with the candidate CIDRs that were generated.
        # Loop through the candidate list until subnet creation does not fail with a CIDR conflict error, or
        # until no candidates remain.
        while len(subnet_cidrs) > 0:
            try:
                cidr = subnet_cidrs.pop(0)
                subnet = vpc.create_subnet(AvailabilityZone=az, CidrBlock=cidr.with_prefixlen)
                # Ensure that the new subnet has the MapPublicIpOnLaunch attribute set
                ec2.meta.client.modify_subnet_attribute(SubnetId=subnet.id,
                                                        MapPublicIpOnLaunch={"Value": True})
                click.echo(f"Created new subnet: {subnet.id}")
                break
            except botocore.exceptions.ClientError as e:
                if e.response["Error"]["Code"] == "InvalidSubnet.Conflict":
                    continue
                raise
        else:
            raise CraftingTableError(f"Could not find valid CIDR to create subnet in {az}")


def configure_routing(vpc):
    """Ensure that the VPC's main route table has a route to the internet gateway."""
    internet_gateways = list(vpc.internet_gateways.all())
    if len(internet_gateways) == 1:
        internet_gateway = internet_gateways[0]
    elif len(internet_gateways) == 0:
        raise CraftingTableError("No internet gateway found")
    else:
        ids = ", ".join(map(lambda igw: igw.id, internet_gateways))
        raise CraftingTableError(f"Multiple internet gateways found: {ids}")

    route_tables = list(vpc.route_tables.filter(Filters=[{"Name": "association.main", "Values": ["true"]}]))
    if len(route_tables) == 1:
        route_table = route_tables[0]
    elif len(route_tables) == 0:
        raise CraftingTableError("No route table found")
    if len(route_tables) != 1:
        ids = ", ".join(map(lambda rtb: rtb.id, route_tables))
        raise CraftingTableError(f"Multiple route tables found: {ids}")

    for route in route_table.routes:
        if route.gateway_id == internet_gateway.id:
            break
    else:
        route_table.create_route(DestinationCidrBlock="0.0.0.0/0", GatewayId=internet_gateway.id)
        click.echo(f"Created default route to {internet_gateway.id}")


def configure_minecraft_security_group(vpc):
    security_groups = list(vpc.security_groups.filter(Filters=[
        {"Name": "tag:elasticraft", "Values": ["minecraftSecurityGroup"]}]))
    if len(security_groups) == 1:
        security_group = security_groups[0]
    elif len(security_groups) == 0:
        raise CraftingTableError("Could not find Minecraft security group")
    else:
        ids = ", ".join(map(lambda sg: sg.id, security_groups))
        raise CraftingTableError(f"Multiple Minecraft security groups: {ids}")

    # Newly-created security groups have an egress permission allowing all outbound traffic that cannot be
    # removed using CloudFormation. Since this security group will be removed at run-time from the network
    # interface, remove this automatically-created rule to ensure that egress permissions are provided by a
    # different security group.
    try:
        security_group.revoke_egress(IpPermissions=[
            {"IpProtocol": "-1", "IpRanges": [{"CidrIp": "0.0.0.0/0"}]}])
        click.echo(f"Revoked default egress permission from {security_group.id}")
    except botocore.exceptions.ClientError as e:
        if e.response["Error"]["Code"] != "InvalidPermission.NotFound":
            raise


@cli.command()
@click.pass_obj
def vpc(ec2):
    vpc = find_vpc(ec2)
    # Retrieve existing subnets to determine which availability zones already have one, and to ensure that
    # their MapPublicIpOnLaunch attribute is set.
    subnets = list(vpc.subnets.all())
    for subnet in filter(lambda subnet: not subnet.map_public_ip_on_launch, subnets):
        ec2.meta.client.modify_subnet_attribute(SubnetId=subnet.id, MapPublicIpOnLaunch={"Value": True})

    create_subnets(ec2, vpc, subnets)
    configure_routing(vpc)
    configure_minecraft_security_group(vpc)


if __name__ == "__main__":
    try:
        cli()
    except CraftingTableError as e:
        click.secho(str(e), fg="red")
        sys.exit(1)
